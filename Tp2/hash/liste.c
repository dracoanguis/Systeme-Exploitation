/*Linked-List Librairy c doc ver: 1.0.0
Author: Ethan Bargaud-Arm*/ 
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "liste.h"


#ifdef _LIST_ADVANCED_ERROR
#define IS_FATAL (1<<0)
#define P_LOG (1<<1)
#define P_STDERR (1<<2) 
//Comportement face au erreurs
int errorListCmp[6] = {IS_FATAL | P_STDERR,P_STDERR,P_STDERR,P_STDERR,P_STDERR,P_STDERR};

void changerCmpError(int newCmp[6]){
    for (int i = 0; i < 6; i++)
    {
        if (newCmp[i] < 7 && newCmp[i] >=0){
            errorListCmp[i] = newCmp[i];
        }
    }
}

#endif //_LIST_ADVANCED_ERROR

void executeError(int type, int loc){

    char errorType[50];

    switch (type)
    {
    case 0:
        strncpy(errorType,"Failed Memory Attribution",50);
        break;
    case 1:
        strncpy(errorType,"Empty or non-existent list passed in argument",50);
        break;
    case 2:
        strncpy(errorType,"List is added to herself",50);
        break;
    case 3:
        strncpy(errorType,"Position superior to size of list",50);
        break;
    case 4:
        strncpy(errorType,"Trying to suppress non-empty list",50);
        break;
    case 5:
        strncpy(errorType,"Object not-found in list",50);
        break;
    
    default:
        strncpy(errorType,"Unknown Error",50);
        break;
    }

    char errorLoc[30];

    switch (loc)
    {
    case 0:
        strncpy(errorLoc,"innitialiserListe",30);
        break;
    case 1:
        strncpy(errorLoc,"ajouterFinElementListe",30);
        break;
    case 2:
        strncpy(errorLoc,"ajouterDebutElementListe",30);
        break;
    case 3:
        strncpy(errorLoc,"compterElementListe",30);
        break;
    case 4:
        strncpy(errorLoc,"supprimerFinElementListe",30);
        break;
    case 5:
        strncpy(errorLoc,"supprimmerDebutElement",30);
        break;
    case 6:
        strncpy(errorLoc,"supprimerNbrElementListe",30);
        break;
    case 7:
        strncpy(errorLoc,"lireDebutElementListe",30);
        break;
    case 8:
        strncpy(errorLoc,"lireFinElementListe",30);
        break;
    case 9:
        strncpy(errorLoc,"lireNbreElementListe",30);
        break;
    case 10:
        strncpy(errorLoc,"supprimerListeVide",30);
        break;
    case 11:
        strncpy(errorLoc,"trouverSupprimerElementListe",30);
        break;
    case 12:
        strncpy(errorLoc,"trouverNbrElementListe",30);
        break;
    default:
        strncpy(errorLoc,"Unknown Localization",30);
        break;
    }

    #ifndef _LIST_ADVANCED_ERROR
        fprintf(stderr,"Error of type:%s at:%s\n",errorType,errorLoc);
    #endif // !_LIST_ADVANCED_ERROR

    #ifdef _LIST_ADVANCED_ERROR
    if (errorListCmp[type] & P_STDERR)
        fprintf(stderr,"Error of type:%s at:%s\n",errorType,errorLoc);
    
    if (errorListCmp[type] & P_LOG){
        FILE* log = fopen("errorList.log",'a');
        fprintf(log,"Error of type:%s at:%s\n",errorType,errorLoc);
        fclose(log);
    }
    if (errorListCmp[type] & IS_FATAL)
        exit(EXIT_FAILURE);

    #endif // _LIST_ADVANCED_ERROR

}

Liste* innitialiserListe()
{
    Liste* new = NULL;
    new = malloc(sizeof(Liste));
    if (new == NULL)
    {
        //Ajouter erreur 0
        executeError(0,0);
    }

    new->head = NULL;
    return new;
}

void ajouterFinElementListe(Liste* list,void* elem)
{
    if (list == NULL)//elem peut etre NULL (abscence de donnée)
    {
        //Ajouter erreur 1
        executeError(1,1);
    }

    if(elem == list)
    {
        //ajouter erreur 2
        executeError(2,1);
    }

    Element* new = NULL;
    new = malloc(sizeof(Element));
    if (new == NULL) {
        //ajouter erreur 0
        executeError(0,1);
    }

    new->data = elem;
    new->next = NULL;

    Element* courant = list->head;

    while (courant != NULL)
    {
        courant = courant->next;
    }

    courant->next = new;
}

void ajouterDebutElementListe(Liste* list,void* elem)
{
    if (list == NULL)
    {
        //Ajouter erreur 1
        executeError(1,2);
    }

    if(list == elem)
    {
        //ajouter erreur 2
        executeError(2,2);
    }

    Element* new = NULL;
    new = malloc(sizeof(Element));
    if (new == NULL)
    {
        //ajouter erreur 0
        executeError(0,2);
    }

    new->data = elem;
    new->next = list->head;
    list->head = new;
}

int compterElementListe(Liste* list)
{
    if(list == NULL)
    {
        //ajouter erreur 1
        executeError(1,3);
    }
    int nbr = 0;

    Element* courant = list->head;

    while (courant != NULL)
    {
        nbr +=1;
        courant = courant->next;
    }
    
    return nbr;
}

void* supprimerFinElementListe(Liste* list)
{
    if (list == NULL || list->head == NULL)
    {
        //ajouter erreur 1
        executeError(1,4);  
    }

    void* rdata = NULL;
    Element* courant = list->head;
    //Courant est l'avant dernier element

    if (list->head->next == NULL){ //Quand il y a un seul element
        rdata = list->head->data;
        free(list->head);
        list->head = NULL;
        return rdata;
    }

    while (courant->next->next != NULL)
    {
        courant = courant->next;
    }
    
    rdata = courant->next->data;
    free(courant->next);
    courant->next = NULL;

    return rdata;
}

void* supprimerDebutElementListe(Liste* list)
{
    if (list == NULL || list->head == NULL)
    {
        //ajouter erreur 1
        executeError(1,5);
    }

    void* rdata = NULL;
    Element* courant = list->head;

    rdata = courant->data;
    list->head = courant->next;
    free(courant);

    return rdata;
}

void* supprimerNbrElementListe(Liste* list,int position)
{
    if (list == NULL || list->head == NULL)
    {
        //ajouter erreur 1
        executeError(1,6);
    }

    int nbr = 0;//Correspond au numéro associer a head
    void* rdata = NULL;
    Element* courant = list->head;

    while (courant != NULL && nbr<position)
    {
        nbr += 1;
        courant = courant->next;
    }

    Element* effacable = courant->next;

    if (nbr<position)
    {
        //ajouter erreur 3
        executeError(3,6);
    }
    
    rdata = effacable->data;
    courant->next = effacable->next;
    free(effacable);

    return rdata;    
}

void* lireDebutElementListe(Liste* list)
{
    if (list == NULL || list->head == NULL)
    {
        //ajouter erreur 1
        executeError(1,7);
    }
     
    return list->head->data;
}

void* lireFinElementListe(Liste* list)
{
    if(list == NULL || list->head == NULL)
    {
        //ajouter erreur 1
        executeError(1,8);
    }

    Element* courant = list->head;

    while (courant->next != NULL)
    {
        courant = courant->next;
    }
    
    return courant->data;
}

void* lireNbrElementListe(Liste* list,int position)
{
    if (list == NULL || list->head == NULL)
    {
        //ajouter erreur 1
        executeError(1,9);
    }

    int nbr = 0; //0 = head
    Element* courant = list->head;

    while (courant != NULL && nbr<position)
    {
        nbr += 1;
        courant = courant->next;
    }
    
    if (nbr<position)
    {
        //ajouter erreur 3
        executeError(1,10);
    }
    
    return courant->data;
}

void supprimerListeVide(Liste* list)
{
    if (list == NULL)
    {
        //ajouter erreur 1
        executeError(1,10);
    }

    if (list->head != NULL)
    {
        //ajouter erreur 4
        executeError(4,10);
    }
    
    free(list);
}

void trouverSupprimerElementListe(Liste* list,void* objet)
{
    if (list == NULL || list->head == NULL)
    {
        //ajouter erreur 1
        executeError(1,11);
    }
    
    Element* courant = list->head;

    while (courant->next->next != NULL && courant->next->data != objet)
    {
        courant = courant->next;
    }
    
    if (courant->next->next == NULL && courant->next->data != objet)
    {
        //ajouter erreur 5
        executeError(5,11);
    }

    Element* effacable = courant->next;
    courant->next = effacable->next;
    free(effacable);
}

int trouverNbrElementListe(Liste* list,void* objet)
{
    if (list == NULL || list->head)
    {
        //ajouter erreur 1
        executeError(1,12);
    }

    int nbr = 0;
    Element* courant = list->head;

    while (courant->next != NULL && courant->data != objet)
    {
        nbr +=1;
        courant = courant->next;
    }
    
    if (courant->next == NULL && courant->data != objet)
    {
        //ajouter erreur 5
        executeError(5,12);
        nbr = -1;
    }

    return nbr;
    
}
