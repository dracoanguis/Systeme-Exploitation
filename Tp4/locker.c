#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <sys/wait.h>

#define INV_ARG {fprintf(stderr,"Incorrect format of arguments\n");printHelp();return -1;}

int printHelp(){

	printf("\tFormat: cmd type start length [whence]\n");
	printf("\tcmd:\t'g' (F_GETLK), 's' (F_SETLK), 'w' (F_SETLKW), '?' to display this help, 'q' to quit or 'n' to make a new child-Process\n");
	printf("\ttype:\t'r' (F_RDLCK), 'w' (F_WRLCK) or 'u' (F_UNLCK)\n");
	printf("\tstart:\tlock starting offset\n");
	printf("\tlength:\tnumber of bytes to lock\n ");
	printf("\twhence:\t's' (SEEK_SET, default), 'c' (SEEK_CUR) or 'e'(SEEK_END)\n");
	printf("\n");

	return 0;
}

int printLock(const struct flock* lock){

	char type[20];

	switch (lock->l_type){
		case F_WRLCK:	strncpy(type,"write lock",20);	break;
		case F_RDLCK:	strncpy(type,"read lock",20);		break;
		case F_UNLCK:	strncpy(type,"unlock lock",20);	break;
		default:		strncpy(type,"unknown lock",20);	break;
	}

	char whence[20];

	switch (lock->l_whence){
		case SEEK_CUR:	strncpy(whence,"current position",20);	break;
		case SEEK_SET:	strncpy(whence,"starting position",20);	break;
		case SEEK_END:	strncpy(whence,"end position",20);		break;
	}

	printf("%s on start: %ld of length: %ld on whence: %s detained by %d\n",type,lock->l_start,lock->l_len,whence,lock->l_pid);

	return 0;
}

int getLock(const int fd, struct flock* lock){

	if (fcntl(fd,F_GETLK,lock) == -1){
		fprintf(stderr,"printLock: fcntl: %s\n",strerror(errno));
		return -1;
	}

	if (lock->l_type == F_UNLCK){
		printf("There is no lock in the selected area.\n");
		return 0;
	}

	printf("There is a: ");
	printLock(lock);
	
	return 0;
}

int setLock(const int fd, struct flock* lock){
	
	if(fcntl(fd,F_SETLK,lock) == -1){
		fprintf(stderr,"setLock: fcntl: %s\n",strerror(errno));
		return -1;
	}

	printf("Putting a: ");
	printLock(lock);
	
	return 0;
}

int setwLock(const int fd, struct flock* lock){
	
	if(fcntl(fd,F_SETLKW,lock) == -1){
		fprintf(stderr,"setwLock: fcntl: %s\n",strerror(errno));
		return -1;
	}

	printf("Putting a: ");
	printLock(lock);
	
	return 0;
}

char* prompt(pid_t pid){

	char* res = calloc(20,sizeof(char));
	printf("%d=> ",pid);
	fflush(stdin);
	if (fgets(res,20,stdin) == NULL) {
		fprintf(stderr,"prompt: fgets error");
		exit(EXIT_FAILURE);
	}
	return res;
}

int parser(const int _fd,const char* _entry){

	char cmd = 'x';
	char type = 'x';
	int start = -1;
	int length = -1;
	char whence = 's';

	int args = 0;

	if((args = sscanf(_entry,"%c %c %d %d %c",&cmd,&type,&start,&length,&whence)) == EOF){
		fprintf(stderr,"parser: sscanf: %s\n",strerror(errno));
		printf("%c %c %d %d %c\n",cmd,type,start,length,whence);
		return -1;
	}

	if (args == 2 || args == 3 || args > 5){
		fprintf(stderr,"Incorrect format of arguments\n");
		printHelp();
		return -1;
	}

	if (cmd == '?'){
		printHelp();
		return 0;
	}

	if (cmd == 'q'){
		return 1;
	}

	if (cmd == 'n'){
		return 2;
	}

	struct flock lock;

	switch (type){
		case 'r':   lock.l_type = F_RDLCK;  break;
		case 'w':   lock.l_type = F_WRLCK;  break;
		case 'u':   lock.l_type = F_UNLCK;  break;
		default:    INV_ARG;			break;
	}

	if (start < 0){
		INV_ARG;
	} else {
		lock.l_start = start;
	}

	if (length < 0){
		INV_ARG;
	} else {
		lock.l_len = length;
	}

	switch (whence){
		case 's':	lock.l_whence = SEEK_SET;	break;
		case 'c':	lock.l_whence = SEEK_CUR;	break;
		case 'e':	lock.l_whence = SEEK_END;	break;
		default:	INV_ARG;				break;
	}

	switch (cmd){
		case 'g':	if(getLock(_fd,&lock)){return -1;}		break;
		case 's':	if(setLock(_fd,&lock)){return -1;}		break;
		case 'w':	if(setwLock(_fd,&lock)){return -1;}		break;
		default:	INV_ARG;						break;
	}

	return 0;
}


int main(int argc, char *argv[]){

	if (argc == 1){
		fprintf(stderr,"%s: no input file precised\n",argv[0]);
		return 0;
	}

	if (argc > 2){
		printf("%s: Ther is too much arguments given, only need one\n",argv[0]);
		return 0;
	}

	int fd;
	if ((fd = open(argv[1],O_RDONLY) == -1 )){
		fprintf(stderr,"%s : open %s : %s\n",argv[0],argv[1],strerror(errno));
		exit(EXIT_FAILURE);
	}

	printf("Welcome to the Locker programme\n");
	printHelp();

	while (1)
	{
		char* input = prompt(getpid());
		int status = parser(fd,input);
		free(input);

		if(status == -1){
			continue;
		}

		if(status == 1){
			break;
		}
		
		if(status == 2){
			pid_t child =  fork();
			if (child == 0){
				while(1){
					char* input2 = prompt(getpid());
					int status2 = parser(fd,input2);
					free(input2);

					if(status2 == -1){
						continue;
					}

					if(status2 == 1){
						break;
					}

					if(status2 == 2){
						fprintf(stderr,"Can only create one child process\n");
						continue;
					}
				}
				return 0;
			} else	{
				printf("New child proccess with pid %d:\n",child);
				wait(NULL);
				printf("You exited child process with pid %d\n",child);
			}
		}
	}
	return 0;
}