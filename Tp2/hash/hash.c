#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include "liste.h"
#include "crypt.h"
#include "option.h"

//Macro to check validity of pointers, weirdly it might provok memory leaks, it actually make one more allocation without freeing it, but every individual part don't provok allocation, I'm crying :,)
// 8 bytes lost per call might be negligeable but still really nerve wraking
//After several test the rythm at which we lose bytes is bit much ~200 bytes in last test, well not that much but still
#define CHECK_POINTER(X) (((X) == NULL) ? ({fprintf(stderr,"Error:"__FILE__":%d: %s\n",__LINE__,strerror(errno)); exit(EXIT_FAILURE);NULL;}) : (X) )

//Digst type used when unprecised
#define BASE_DIGEST "sha1"

//Definition of external values of getopt defined in unistd
extern int optind, opterr, optopt;
extern char* optarg;

void Hachage_DFile(Liste* dfiles){
    DFile* courrant = NULL;
    while (dfiles->head != NULL)
    {
        courrant = supprimerFinElementListe(dfiles);
        Hachage_File(courrant->fichier,courrant->digest);
        DFile_End(courrant);
    }
}

int main(int argc, char *argv[])
{
    char* digest = calloc(TAILLE_DIGEST,sizeof(char));
    strncpy(digest,BASE_DIGEST,TAILLE_DIGEST);

    Liste* fichiers = CHECK_POINTER( innitialiserListe() );

    int opt;
    int args;
    char bfile = 0;//Just a bool not really efficient but it's the only one 
    while ((opt = getopt(argc, argv,"hft:")) != -1)
    {
        switch (opt)
        {
        case 'f': //If -f used ignore, if exist, the string before it, does register digest selection before it thought
            args = (optind);
            while (args < argc && strcmp(argv[args],"-t"))
            {
                ajouterDebutElementListe(fichiers, CHECK_POINTER( DFile_Init(argv[args],digest)) );
                args +=1;
            }
            bfile = 1;
            break;
        
        case 't':
            strncpy(digest,optarg,TAILLE_DIGEST);

            if (bfile) //whole block to not have to put -f again after declaration
            {
                args = (optind);
                while (args < argc && strcmp(argv[args],"-t"))
                {
                    ajouterDebutElementListe(fichiers, CHECK_POINTER( DFile_Init(argv[args],digest)) );
                    args +=1;
                }
            }
            
            break;

        case 'h':
            printf("Usage: hash.exe [options] DATA ... \nOptions:\n");
            printf("\t-f FILE \tRead from a file/file list instead of reading a string\n");
            printf("\t-h \t\tDisplay this help and exit\n");
            printf("\t-t DIGEST\tChange the digest used to hash the input, base one is sha1\n");
            exit(EXIT_SUCCESS);


        default://Supposed to never happen because if no argument the whole switch is passed
            fprintf(stderr,"There seems to be an Error somewhere.\n");
            break;
        }
    }
    
    if (fichiers->head != NULL){//File treatment 
        Hachage_DFile(fichiers);
    } else {//String treatment
        int taille = 0;//Taille total des chaines
        args = (argc-optind);//Nombre de chaine
        for (int i = optind; i < argc; i++)
        {
            taille += strlen(argv[i]);
        }
        char* message = CHECK_POINTER( calloc(taille+args-1,sizeof(char)) );
        for (int i = optind; i < argc; i++)
        {
            strncat(message,argv[i],strlen(argv[i]));
            if (i != argc-1){
                strncat(message," ",2);
            }
        }

        Hachage_String(message,digest);
        free(message);
    }

    free(digest);
    supprimerListeVide(fichiers);
    return 0;
}
