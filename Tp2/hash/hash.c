#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "crypt.h"
#include "option.h"
#define BASE_DIGEST "sha1"

void Hachage_DFile(Liste* dfiles){
    DFile* courrant = NULL;
    while ((courrant = Liste_POP(dfiles)) != NULL)
    {
        Hachage_File(courrant->fichier,courrant->digest);
        DFile_End(courrant);
    }
}

int main(int argc, char *argv[])
{
    char* digest = calloc(TAILLE_DIGEST,sizeof(char));
    strncpy(digest,BASE_DIGEST,TAILLE_DIGEST);

    Liste* fichiers = Liste_Init();

    int opt;
    int args;
    while ((opt = getopt(argc, argv,"f:t:")) != -1)
    {
        switch (opt)
        {
        case 'f':
            args = (optind-1);
            while (args < argc && strcmp(argv[args],"-t"))
            {
                Liste_ADD(fichiers, DFile_Init(argv[args],digest));
                args +=1;
            }
            break;
        
        case 't':
            strncpy(digest,optarg,TAILLE_DIGEST);
            break;

        default:
            printf("There seems to be an Error somewhere.\n");
            break;
        }
    }
    
    if (fichiers->first != NULL){
        Hachage_DFile(fichiers);
    } else {
        int taille = 0;//Taille total des chaines
        args = (argc-optind);//Nombre de chaine
        for (int i = optind; i < argc; i++)
        {
            taille += strlen(argv[i]);
        }
        char* message = calloc(taille+args-1,sizeof(char));//Toujours supérieur ou égal 0 malgré ce que dit valgrind car args vaut au minimum 1 a cause de l'argument 0 qui est le nom de l'éxécutable
        for (int i = optind; i < argc; i++)
        {
            strncat(message,argv[i],strlen(argv[i]));
            if (i != argc-1){
                strncat(message," ",2);
            }
        }

        Hachage_String(message,digest);
        free(message);
    }
    

    free(digest);
    Liste_End(fichiers);
    return 0;
}
