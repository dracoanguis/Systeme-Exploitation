\documentclass{article}
\usepackage{minted}
\usepackage{xcolor}
\title{Système d'Exploitation - TP1}
\author{Ethan Arm}

\begin{document}
    \maketitle
    
    \section{Exercises}
        \subsection{Commande 'man'}
            \paragraph*{}
                La commande 'man' permet d'obternir des informations sur les différentes commande du shell.
                
        \subsection{Commande 'echo'}
            \paragraph*{}
                La commande 'echo' permet d'afficher une ligne de text. Cette commande peut prendre des options en paramètre optionel et une String en paramètre obligatoire.

        \subsection{Create a 'file'}
            \paragraph*{}
                La commande 'touch' permet de changer le timestamp d'un fichier passer en paramètre, et si celui-ci n'existe pas cela créée un fichier vide avec le nom passer en paramètre.
                Par exemple: \mintinline{bash}{touch foo.txt} crée un fichier foo.txt.
            
        \subsection{Lancement de programmes}
            \paragraph*{}
                On essaye de lancer vscode sur \mintinline{bash}{~/sysExp/Tp1},\\on tape donc \mintinline{bash}{code ~/sysExp/Tp1} et on voit bien se lancer VS code.

        \subsection{Fichiers}   
            \paragraph*{a)}
                Pour les deux première commandes ils se passent la même chose. En effet, dans le cas de \mintinline{bash}{wc -w < foo.txt} le contenu du fichier foo.txt est passé en entrée standart de la commande \mintinline{bash}{wc -w}.
                Il se passe la même chose dans la commande \mintinline{bash}{cat foo.txt | wc -w}. Ces deux commandes compté le nombre de mots dans le contenus du fichier foo.txt.
                Dans le cas de la troisième commande \mintinline{bash}{wc -w foo.txt} le fichier foo.txt est directement passé à la commande \mintinline{bash}{wc -w} c'est donc cette commande qui lit a l'intérieur du fichier. On peut d'ailleur selon ce modèle passé une liste de fichiers en argument et il comptera alors tous les mots dans les fichiers de celle-ci.

            \paragraph*{b)}
                La commande \mintinline{bash}{head foo.txt -n 6} permet d'afficher les six première ligne du fichier foo.txt. A son inverse, la commande \mintinline{bash}{tail foo.txt -n 6} permet d'afficher les six dernière ligne du fichier foo.txt.

            \paragraph*{c)}
                Les fichiers out1.txt et out2.txt diffère, en effet quand foo.txt existe out1.txt est remplie du contenu trier de foo.txt et out2.txt est vide. A contrario lorsque foo.txt n'existe pas out1.txt est vide et out2.txt contient l'erreur du sort qui dis que le fichier foo.txt n'existe pas.
                Cela est normal car l'opérateur \mintinline{bash}{>} redirige le contenu de la sortie standart (la sortie du sort) et l'opérateur \mintinline{bash}{2>} redirige le flux d'erreur standart, l'endroit ou apparaisse les erreurs. Par conséquents le contenu des deux fichiers est différent.
            
        \subsection{Écrivez un script}
            \paragraph*{}
                On commence par crée un dossier \mintinline{bash}{image/} (parce que vive les cas critiques) et on place plusieurs images avec differentes noms et extension, même du texte à l'intérieur. On écrit ensuite un script dans le fichier \mintinline{bash}{convertImage.sh}. Il est important de noter que \mintinline{bash}{convertImage.sh} ne fait pas d'éxécution récursif, s'il y a un sous-dossier dans le dossier celui-ci est ignoré et sont contenue aussi.
                De plus, la vérification du troisième argument n'est pas fait par le script mais par la commande \mintinline{bash}{convert} de \emph{imagemagick}, car il exite d'autre mots-clefs autre qu'une simple résolution.

\end{document}